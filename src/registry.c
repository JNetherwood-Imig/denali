#include "display.h"
#include "registry.h"
#include "protocol.h"
#include "vector.h"

#include <string.h>
#include <sys/epoll.h>

void registry_bind(const Registry* const self, const RegistryGlobal* const global,
                   const u32 version, Object* const object) {
    *object = (Object){
        .id = self->display->next_id++,
        .bound_version = version,
        .global = *global,
        .display = self->display,
    };

    display_send_message(self->display, self->id, WL_REGISTRY_REQUEST_BIND,
                         WL_REGISTRY_BIND_SIGNATURE, global->name, global->interface,
                         version, object->id);
}

const RegistryGlobal* registry_lookup_interface(const Registry* const self,
                                                const char* const interface) {
    for (RegistryGlobal* glob = vector_begin(self->globals); glob != vector_end(self->globals); ++glob) {
        if (strcmp(glob->interface, interface) == 0)
            return glob;
    }

    return nullptr;
}

// handlers, should probably be placed in separate registry_protocol.h file which is
// autogenerated from xml
void registry_handle_global(Registry* const self, const u32 name,
                            const char* const interface, const u32 version) {
    
}

void registry_handle_global_remove(Registry* const self, const u32 name) {
    
}

/* ################################################################ */

#define REGISTRY_INITIAL_CAPACITY 32U

bool display_get_registry(DwlDisplay* display) {
    display->registry.id = display->next_id++;
    display->registry.display = display;
    display->registry.globals =
        vector_reserve(RegistryGlobal, REGISTRY_INITIAL_CAPACITY);

    display_send_message(display, display->id, WL_DISPLAY_REQUEST_GET_REGISTRY,
                         WL_DISPLAY_GET_REGISTRY_SIGNATURE, display->registry.id);


    return true;
}

void display_destroy_registry(DwlDisplay* display) {
    vector_destroy(display->registry.globals);
}

